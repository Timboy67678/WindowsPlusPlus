#include "..\window.hpp"
#include "..\thunk.hpp"

namespace wpp
{
	window::window(window_class wnd_class, const tstring& window_name, int x_pos, int y_pos, int width, int height, DWORD style,
				   int menu_id, HMENU menu, HFONT font, DWORD style_ex)
		: hwnd(NULL), m_window_class(wnd_class), m_window_name(window_name), m_x_pos(x_pos), m_y_pos(y_pos),
		m_width(width), m_height(height), m_style(style), m_menu_id(menu_id), m_menu_handle(menu), m_font(font), m_style_ex(style_ex) {
		init_message_events();
	}

	window::~window() {
		if (m_window_running) {
			::PostQuitMessage(0);
			cleanup();
		}
	}

	void window::init_message_events() {
		using namespace std::placeholders;

		m_message_events = {
			{WM_CREATE, std::bind(&window::on_create, this, _1, _2, _3)},
			{WM_CLOSE, std::bind(&window::on_close, this, _1, _2, _3)},
			{WM_QUIT, std::bind(&window::on_quit, this, _1, _2, _3)},
			{WM_DESTROY, std::bind(&window::on_destroy, this, _1, _2, _3)},
			{WM_DISPLAYCHANGE, std::bind(&window::on_display_change, this, _1, _2, _3)},
			{WM_MOVE, std::bind(&window::on_move, this, _1, _2, _3)},
			{WM_COMMAND, std::bind(&window::on_command, this, _1, _2, _3)},
			{WM_MENUCOMMAND, std::bind(&window::on_menu_command, this, _1, _2, _3)},
			{WM_PAINT, std::bind(&window::on_paint, this, _1, _2, _3)},
			{WM_TIMER, std::bind(&window::on_timer, this, _1, _2, _3)},
			{WM_SIZE, std::bind(&window::on_size, this, _1, _2, _3)},
			{WM_KEYDOWN, std::bind(&window::on_key_down, this, _1, _2, _3)},
			{WM_KEYUP, std::bind(&window::on_key_up, this, _1, _2, _3)},
			{WM_NOTIFY, std::bind(&window::on_notify, this, _1, _2, _3)},
			{WM_HSCROLL, std::bind(&window::on_h_scroll, this, _1, _2, _3)},
			{WM_VSCROLL, std::bind(&window::on_v_scroll, this, _1, _2, _3)},
			{WM_DROPFILES, std::bind(&window::on_drop_files, this, _1, _2, _3)},
			{WM_CTLCOLOREDIT, std::bind(&window::on_ctl_color_edit, this, _1, _2, _3)},
			{WM_DPICHANGED, std::bind(&window::on_dpi_changed, this, _1, _2, _3)},
			{WM_CTLCOLORSTATIC, std::bind(&window::on_ctl_color_static, this, _1, _2, _3)},
		};
	}

	void window::cleanup() {
		for (auto& timer : m_timer_events)
			::KillTimer(m_handle, timer.first);
		for (auto& control_pair : m_controls) {
			::DestroyWindow(control_pair->get_handle());
			control_pair.reset();
		}

		m_controls.clear();
		m_timer_events.clear();
		m_menu_command_events.clear();

		::DeleteObject(m_font); m_font = NULL;
		::DestroyMenu(m_menu_handle); m_menu_handle = NULL;
		::DestroyWindow(m_handle); m_handle = NULL;

		m_control_id = WM_USER + 1; // reset counter
	}

	BOOL window::handle_scroll_message(scroll_orientation orientation, WPARAM wParam, LPARAM lParam) {
		HWND hScrollBar = (HWND)lParam;

		auto scrollbar = get_control_by_handle<scroll_bar>(hScrollBar);
		if (scrollbar) {
			int action = LOWORD(wParam);

			switch (action) {
			case SB_LINEUP:
				scrollbar->scroll_up(1, FALSE);
				break;
			case SB_LINEDOWN:
				scrollbar->scroll_down(1, FALSE);
				break;
			case SB_PAGEUP:
				scrollbar->page_up(FALSE);
				break;
			case SB_PAGEDOWN:
				scrollbar->page_down(FALSE);
				break;
			case SB_THUMBTRACK:
			case SB_THUMBPOSITION:
				scrollbar->set_scroll_pos(HIWORD(wParam), TRUE);
				break;
			case SB_TOP:
				scrollbar->scroll_to_top(FALSE);
				break;
			case SB_BOTTOM:
				scrollbar->scroll_to_bottom(FALSE);
				break;
			}

			scrollbar->on_scroll_event(orientation, wParam, lParam);
			return TRUE;
		}
		return FALSE;
	}

	bool window::create_window(HWND parent_window, LPVOID param) {
		m_parent_handle = parent_window;

		if (m_window_class.atom() != NULL)
			m_window_class.Unregister();

		auto thunk = new Win32Thunk<WNDPROC, window>{ &window::window_proc, this };
		m_thunk_storage = std::unique_ptr<void, void(*)(void*)>(
			thunk,
			+[](void* p) { delete reinterpret_cast<Win32Thunk<WNDPROC, window>*>(p); }
		);
		m_window_class.get().lpfnWndProc = thunk->GetThunk();
		m_window_class.Register();

		m_handle = ::CreateWindowEx(m_style_ex, m_window_class.class_name(), m_window_name.c_str(), m_style,
									m_x_pos, m_y_pos, m_width, m_height, m_parent_handle, m_menu_handle, m_window_class.instance(), param);

		if (!m_handle)
			return false;

		// If no font was provided, create a default one (Segoe UI, 12pt)
		if (m_font == NULL) {
			m_font = ::CreateFont(
				-12, 0, 0, 0,
				FW_NORMAL, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
				CLIP_DEFAULT_PRECIS, CLEARTYPE_QUALITY, DEFAULT_PITCH | FF_DONTCARE, TEXT("Segoe UI"));
		}

		set_font(m_font);

		for (auto& control : m_controls)
			control->set_font(m_font);

		if (m_layout_panel) {
			m_layout_panel->set_parent_window(m_handle);
			RECT rc = get_rect();
			m_layout_panel->measure(rc.right, rc.bottom);
			m_layout_panel->arrange(0, 0, rc.right, rc.bottom);
		}

		show_window();
		::UpdateWindow(m_handle);

		m_window_running = true;

		return true;
	}

	bool window::run_window(HWND parent_window, LPVOID param) {
		if (!create_window(parent_window, param))
			return false;

		show_window();
		::UpdateWindow(m_handle);

		MSG msg;
		while (m_window_running && ::GetMessage(&msg, NULL, NULL, NULL)) {
			if (!::IsDialogMessage(m_handle, &msg)) {
				::TranslateMessage(&msg);
				::DispatchMessage(&msg);
			}
		}

		m_window_running = false;

		return true;
	}

	LRESULT window::window_proc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam) {
		m_handle = hWnd;
		LRESULT ret = FALSE;
		auto it = m_message_events.find(Msg);
		if (it != m_message_events.end())
			ret = it->second(hWnd, wParam, lParam);

		if (ret == FALSE) //was handled? otherwise send to default os handler
			return ::DefWindowProc(hWnd, Msg, wParam, lParam);
		else
			return ret;
	}

#pragma region Window Control Creators
#pragma warning(push)
#pragma warning(disable: 4312)
	control_ptr<radio_button> window::radio_button_group::create_button(const tstring& text, int x, int y, int width, int height, BOOL initial_state) {
		auto control_id = m_parent->m_control_id++;

		DWORD style = WS_CHILD | WS_VISIBLE | WS_OVERLAPPED;
		if (m_radio_buttons.empty())
			style |= WS_GROUP;

		HWND radiobutton_handle = ::CreateWindowEx(0, WC_BUTTON, text.c_str(), BS_AUTORADIOBUTTON | style,
												   x, y, width, height, m_parent->m_handle, reinterpret_cast<HMENU>(control_id), m_parent->m_window_class.instance(), NULL);
		if (!radiobutton_handle)
			return nullptr;

		auto radiobutton = std::make_shared<radio_button>(control_id, m_parent->m_handle);
		if (!radiobutton) {
			::DestroyWindow(radiobutton_handle);
			return nullptr;
		}

		radiobutton->set_checked(initial_state ? BST_CHECKED : BST_UNCHECKED);
		m_radio_buttons.push_back(radiobutton);
		m_parent->m_controls.emplace_back(radiobutton);

		return radiobutton;
	}

	int window::radio_button_group::selected_index() {
		for (size_t index = 0; index < m_radio_buttons.size(); ++index) {
			if (m_radio_buttons[index]->get_checked() == BST_CHECKED)
				return static_cast<int>(index);
		}
		return -1;
	}

	control_ptr<window::radio_button_group> window::create_radio_button_group() {
		return std::make_shared<radio_button_group>(this);
	}

	control_ptr<button> window::create_button(const tstring& text, int x, int y, int width, int height, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		HWND button_handle = ::CreateWindowEx(style_ex, WC_BUTTON, text.c_str(), style,
											  x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!button_handle)
			return nullptr;

		auto button_ctrl = std::make_shared<button>(control_id, m_handle);
		if (!button_ctrl) {
			::DestroyWindow(button_handle);
			return nullptr;
		}

		m_controls.emplace_back(button_ctrl);
		return button_ctrl;
	}

	control_ptr<check_box> window::create_check_box(const tstring& text, int x, int y, int width, int height, BOOL initial_state, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		HWND checkbox_handle = ::CreateWindowEx(style_ex, WC_BUTTON, text.c_str(), style,
											x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!checkbox_handle)
			return nullptr;

		auto checkbox = std::make_shared<check_box>(control_id, m_handle);
		if (!checkbox) {
			::DestroyWindow(checkbox_handle);
			return nullptr;
		}

		checkbox->set_checked(initial_state ? BST_CHECKED : BST_UNCHECKED);
		m_controls.emplace_back(checkbox);
		return checkbox;
	}

	control_ptr<group_box> window::create_group_box(const tstring& text, int x, int y, int width, int height, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		HWND groupbox_handle = ::CreateWindowEx(style_ex, WC_BUTTON, text.c_str(), style,
											x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!groupbox_handle)
			return nullptr;

		auto groupbox = std::make_shared<group_box>(control_id, m_handle);
		if (!groupbox) {
			::DestroyWindow(groupbox_handle);
			return nullptr;
		}

		m_controls.emplace_back(groupbox);
		return groupbox;
	}

	control_ptr<static_control> window::create_static_control(const tstring& text, int x, int y, int width, int height, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		HWND static_handle = ::CreateWindowEx(style_ex, WC_STATIC, text.c_str(), style,
										  x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!static_handle)
			return nullptr;

		auto static_ctrl = std::make_shared<static_control>(control_id, m_handle);
		if (!static_ctrl) {
			::DestroyWindow(static_handle);
			return nullptr;
		}

		m_controls.emplace_back(static_ctrl);
		return static_ctrl;
	}

	control_ptr<combo_box> window::create_combo_box(int x, int y, int width, int height, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		HWND combobox_handle = ::CreateWindowEx(style_ex, WC_COMBOBOX, _T(""), style,
											x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!combobox_handle)
			return nullptr;

		auto combobox = std::make_shared<combo_box>(control_id, m_handle);
		if (!combobox) {
			::DestroyWindow(combobox_handle);
			return nullptr;
		}

		m_controls.emplace_back(combobox);
		return combobox;
	}

	control_ptr<edit_text> window::create_edit_text(int x, int y, int width, int height, const tstring& initial_text, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		HWND edittext_handle = ::CreateWindowEx(style_ex, WC_EDIT, initial_text.c_str(), style,
											x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!edittext_handle)
			return nullptr;

		auto edittext = std::make_shared<edit_text>(control_id, m_handle);
		if (!edittext) {
			::DestroyWindow(edittext_handle);
			return nullptr;
		}

		m_controls.emplace_back(edittext);
		return edittext;
	}

	control_ptr<list_box> window::create_list_box(int x, int y, int width, int height, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		HWND listbox_handle = ::CreateWindowEx(style_ex, WC_LISTBOX, _T(""), style,
										   x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!listbox_handle)
			return nullptr;

		auto listbox = std::make_shared<list_box>(control_id, m_handle);
		if (!listbox) {
			::DestroyWindow(listbox_handle);
			return nullptr;
		}

		m_controls.emplace_back(listbox);
		return listbox;
	}

	control_ptr<list_view> window::create_list_view(int x, int y, int width, int height, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		HWND listview_handle = ::CreateWindowEx(style_ex, WC_LISTVIEW, _T(""), style,
											x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!listview_handle)
			return nullptr;

		auto listview = std::make_shared<list_view>(control_id, m_handle);
		if (!listview) {
			::DestroyWindow(listview_handle);
			return nullptr;
		}

		m_controls.emplace_back(listview);
		return listview;
	}

	control_ptr<tree_view> window::create_tree_view(int x, int y, int width, int height, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		HWND treeview_handle = ::CreateWindowEx(style_ex, WC_TREEVIEW, _T(""), style,
											x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!treeview_handle)
			return nullptr;

		auto treeview = std::make_shared<tree_view>(control_id, m_handle);
		if (!treeview) {
			::DestroyWindow(treeview_handle);
			return nullptr;
		}

		m_controls.emplace_back(treeview);
		return treeview;
	}

	control_ptr<tab_control> window::create_tab_control(int x, int y, int width, int height, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		HWND tabcontrol_handle = ::CreateWindowEx(style_ex, WC_TABCONTROL, _T(""), style,
											  x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!tabcontrol_handle)
			return nullptr;

		auto tabcontrol = std::make_shared<tab_control>(control_id, m_handle);
		if (!tabcontrol) {
			::DestroyWindow(tabcontrol_handle);
			return nullptr;
		}

		m_controls.emplace_back(tabcontrol);
		return tabcontrol;
	}

	control_ptr<progress_bar> window::create_progress_bar(int x, int y, int width, int height, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		HWND progressbar_handle = ::CreateWindowEx(style_ex, PROGRESS_CLASS, _T(""), style,
											   x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!progressbar_handle)
			return nullptr;

		auto progressbar = std::make_shared<progress_bar>(control_id, m_handle);
		if (!progressbar) {
			::DestroyWindow(progressbar_handle);
			return nullptr;
		}

		m_controls.emplace_back(progressbar);
		return progressbar;
	}

	control_ptr<up_down_control> window::create_spin_control(int x, int y, int width, int height, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		HWND spincontrol_handle = ::CreateWindowEx(style_ex, UPDOWN_CLASS, _T(""), style,
											   x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!spincontrol_handle)
			return nullptr;

		auto spincontrol = std::make_shared<up_down_control>(control_id, m_handle);
		if (!spincontrol) {
			::DestroyWindow(spincontrol_handle);
			return nullptr;
		}

		m_controls.emplace_back(spincontrol);
		return spincontrol;
	}

	control_ptr<rich_edit_text> window::create_rich_edit(int x, int y, int width, int height, const tstring& initial_text, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		if (::GetModuleHandle(TEXT("Riched20.dll")) == NULL) {
			if (::LoadLibrary(TEXT("Riched20.dll")) == NULL) {
				return nullptr;
			}
		}

		HWND richedit_handle = ::CreateWindowEx(style_ex, RICHEDIT_CLASS, initial_text.c_str(), style,
											x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!richedit_handle) {
			return nullptr;
		}

		auto richedit = std::make_shared<rich_edit_text>(control_id, m_handle);
		if (!richedit) {
			::DestroyWindow(richedit_handle);
			return nullptr;
		}

		m_controls.emplace_back(richedit);
		return richedit;
	}

	control_ptr<sys_link> window::create_link_control(const tstring& text, int x, int y, int width, int height, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		HWND linkcontrol_handle = ::CreateWindowEx(style_ex, WC_LINK, text.c_str(), style,
											   x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!linkcontrol_handle)
			return nullptr;

		auto linkcontrol = std::make_shared<sys_link>(control_id, m_handle);
		if (!linkcontrol) {
			::DestroyWindow(linkcontrol_handle);
			return nullptr;
		}

		m_controls.emplace_back(linkcontrol);
		return linkcontrol;
	}

	control_ptr<up_down_control> window::create_updown_control(int x, int y, int width, int height, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		HWND updown_handle = ::CreateWindowEx(style_ex, UPDOWN_CLASS, _T(""), style,
										  x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!updown_handle)
			return nullptr;
		auto updown = std::make_shared<up_down_control>(control_id, m_handle);
		if (!updown) {
			::DestroyWindow(updown_handle);
			return nullptr;
		}
		m_controls.emplace_back(updown);
		return updown;
	}

	control_ptr<scroll_bar> window::create_scroll_bar(scroll_orientation orientation, int x, int y, int width, int height, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;
		DWORD orientation_style = (orientation == scroll_orientation::horizontal) ? SBS_HORZ : SBS_VERT;
		HWND scrollbar_handle = ::CreateWindowEx(style_ex, WC_SCROLLBAR, _T(""), orientation_style | style,
											x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!scrollbar_handle)
			return nullptr;
		auto scrollbar = std::make_shared<scroll_bar>(control_id, m_handle);
		if (!scrollbar) {
			::DestroyWindow(scrollbar_handle);
			return nullptr;
		}
		m_controls.emplace_back(scrollbar);
		return scrollbar;
	}

	control_ptr<track_bar> window::create_track_bar(int x, int y, int width, int height, DWORD style, DWORD style_ex) {
		auto control_id = m_control_id++;

		HWND trackbar_handle = ::CreateWindowEx(style_ex, TRACKBAR_CLASS, _T(""), style,
											x, y, width, height, m_handle, reinterpret_cast<HMENU>(control_id), m_window_class.instance(), NULL);
		if (!trackbar_handle)
			return nullptr;

		auto trackbar = std::make_shared<track_bar>(control_id, m_handle);
		if (!trackbar) {
			::DestroyWindow(trackbar_handle);
			return nullptr;
		}

		m_controls.emplace_back(trackbar);
		return trackbar;
	}

#pragma warning(pop)
#pragma endregion

#pragma region Window Message Handlers
	LRESULT window::on_create(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		if (m_menu_id != -1)
			m_menu_handle = ::LoadMenu(m_window_class.instance(), MAKEINTRESOURCE(m_menu_id));

		return TRUE;
	}

	LRESULT window::on_close(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		quit_window();
		return TRUE;
	}

	LRESULT window::on_quit(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		return TRUE;
	}

	LRESULT window::on_destroy(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		return TRUE;
	}

	LRESULT window::on_paint(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		return FALSE;
	}

	LRESULT window::on_display_change(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		::InvalidateRect(m_handle, NULL, FALSE);
		return TRUE;
	}

	LRESULT window::on_move(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		return FALSE;
	}

	LRESULT window::on_timer(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		auto it = m_timer_events.find(static_cast<UINT_PTR>(wParam));
		if (it != m_timer_events.end()) {
			it->second();
			return TRUE;
		}
		return FALSE;
	}

	LRESULT window::on_size(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		if (m_layout_panel != nullptr) {
			int new_width = LOWORD(lParam);
			int new_height = HIWORD(lParam);
			m_layout_panel->measure(new_width, new_height);
			m_layout_panel->arrange(0, 0, new_width, new_height);
		}
		return FALSE;
	}

	LRESULT window::on_key_down(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		return FALSE;
	}

	LRESULT window::on_key_up(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		return FALSE;
	}

	LRESULT window::on_notify(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		auto nm = reinterpret_cast<LPNMHDR>(lParam);
		for (auto& control : m_controls)
			if (control && nm->idFrom == control->get_id())
				control->on_notify_callback(nm);
		return FALSE;
	}

	LRESULT window::on_h_scroll(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		if (lParam != 0) {
			return handle_scroll_message(scroll_orientation::horizontal, wParam, lParam);
		}
		return FALSE;
	}

	LRESULT window::on_v_scroll(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		if (lParam != 0) {
			return handle_scroll_message(scroll_orientation::vertical, wParam, lParam);
		}
		return FALSE;
	}

	LRESULT window::on_drop_files(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		return FALSE;
	}

	LRESULT window::on_ctl_color_edit(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		return FALSE;
	}

	LRESULT window::on_ctl_color_static(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		return FALSE;
	}

	LRESULT window::on_menu_command(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		return FALSE;
	}

	LRESULT window::on_dpi_changed(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		if (m_layout_panel) {
			float new_dpi = HIWORD(wParam) / 96.0f;
			m_layout_panel->set_dpi_scale(new_dpi);
		}
		return FALSE;
	}

	LRESULT window::on_command(HWND hWnd, WPARAM wParam, LPARAM lParam) {
		UINT commandID = LOWORD(wParam);
		UINT notificationCode = HIWORD(wParam);

		// Check if the command is a menu command
		if (notificationCode == 0 && m_menu_command_events.count(commandID) != 0) {
			m_menu_command_events[commandID](wParam, lParam);
			return TRUE;
		}

		// Check if the command is from a control
		auto control = get_control(commandID);
		if (control) {
			control->on_command_callback(wParam, lParam);
			return TRUE;
		}

		return FALSE;
	}
#pragma endregion

	void window::show_window() {
		::ShowWindow(m_handle, SW_SHOWNORMAL);
	}

	void window::hide_window() {
		::ShowWindow(m_handle, SW_HIDE);
	}

	void window::close_window() {
		::CloseWindow(m_handle);
	}

	void window::quit_window(INT exit_code) {
		m_window_running = false;
		cleanup();
	}
}
